{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<script>\n",
       "code_show=true; \n",
       "function code_toggle() {\n",
       " if (code_show){\n",
       " $('div.input').hide();\n",
       " } else {\n",
       " $('div.input').show();\n",
       " }\n",
       " code_show = !code_show\n",
       "} \n",
       "$( document ).ready(code_toggle);\n",
       "</script>\n",
       "<form action=\"javascript:code_toggle()\"><input type=\"submit\" value=\"Click here to toggle on/off the raw code.\"></form>"
      ],
      "text/plain": [
       "<IPython.core.display.HTML object>"
      ]
     },
     "execution_count": 47,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from IPython.display import HTML\n",
    "\n",
    "HTML('''<script>\n",
    "code_show=true; \n",
    "function code_toggle() {\n",
    " if (code_show){\n",
    " $('div.input').hide();\n",
    " } else {\n",
    " $('div.input').show();\n",
    " }\n",
    " code_show = !code_show\n",
    "} \n",
    "$( document ).ready(code_toggle);\n",
    "</script>\n",
    "<form action=\"javascript:code_toggle()\"><input type=\"submit\" value=\"Click here to toggle on/off the raw code.\"></form>''')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import tensorflow as tf\n",
    "import keras\n",
    "from keras.models import Sequential\n",
    "from keras.layers import Dense, Flatten, Conv2D, Dropout, MaxPooling2D,BatchNormalization\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.model_selection import StratifiedKFold\n",
    "from sklearn.model_selection import KFold\n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "from sklearn.metrics import accuracy_score\n",
    "from collections import Counter"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Codes to load the dataset \n",
    "train = np.load('train_images.npy')\n",
    "valid = np.load('test_images.npy')\n",
    "train_label = np.load('train_labels.npy')\n",
    "# change the data into pandas dataframe\n",
    "train = pd.DataFrame(train)\n",
    "valid = pd.DataFrame(valid)\n",
    "train_label = pd.DataFrame(train_label)\n",
    "train_label.columns = ['labels']"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 1 Exploratory Analysis (10 points)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "I first try to understand the dataset and how it works. So this dataset is a dataset of fashion images. Each observation contains 784 columns which is to combine a 28x28 image matrix into one row. Our task is to classify each observation into categories based on their image information.\n",
    "\n",
    "My english is not that good, therefore I use my own understandings to give each labels name based on their graphical representations, which is 0 represents as T shirt, 1 as pants, 2 as heavier than shirt, 3 as dress, 4 as coat, 5 as sandal, 6 as shirt, 7 as sneaker, 8 as bag and 9 as ankle Boot.\n",
    "\n",
    "First I try to observe in the training set, how many numbers of observations do each class represent? Is it a biased dataset or it's equal weighted? I got the result:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'T-shirt': 5543,\n",
       " 'Coat': 5444,\n",
       " 'Bag': 5496,\n",
       " 'Shirt': 5499,\n",
       " 'Sandal': 5512,\n",
       " 'Dress': 5507,\n",
       " 'Heavier than shirt': 5507,\n",
       " 'Ankle Boot': 5488,\n",
       " 'Sneaker': 5510,\n",
       " 'Pants': 5494}"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#create the dictionary for each labels \n",
    "#used to output the different fashion styles numbers\n",
    "data_label = {0 : \"T-shirt\", 1: \"Pants\", 2: \"Heavier than shirt\", 3: \"Dress\", 4: \"Coat\",\n",
    "          5: \"Sandal\", 6: \"Shirt\", 7: \"Sneaker\", 8: \"Bag\", 9: \"Ankle Boot\"}\n",
    "\n",
    "label_c = train_label[\"labels\"].value_counts() #count the different label appearance time \n",
    "label_c.keys()[1]\n",
    "d = {}\n",
    "for i in range(len(label_c)):\n",
    "    #append the value counts to the corresponding label names in the data_label dic created above\n",
    "    index = label_c.keys()[i]# get the keys\n",
    "    l = data_label[index] #corresponding to the label name\n",
    "    d[l] = label_c[i]# match the value counts \n",
    "d"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 1080x360 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "#Create the visualization of the dic above \n",
    "dd = pd.DataFrame(d,index=[0]).T\n",
    "dd.columns = ['num']\n",
    "fig = plt.subplots(figsize=(15,5))\n",
    "plt.bar(dd.index,dd.num)\n",
    "pass"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Therefore, we can see that we have a balanced dataset with approximately equal number of observations for each label. So what we are going to do is a balanced image classification dataset and we read information from the 28x28 pixels and classify the corresponding labels to each observation. \n",
    "\n",
    "In order to get a more clear idea on how the image looks like, I visualize 5 sample graphs of each label class as below: "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "labels = np.load('train_labels.npy')\n",
    "train2 = train.copy()\n",
    "train2['labels'] = labels"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "plt_images = []\n",
    "plt_labels = []\n",
    "\n",
    "    \n",
    "for i in label_c.keys():\n",
    "    #for all labels i in the dataset \n",
    "    s = train2[train2[\"labels\"] == i] # get all observations with the corresponding label i\n",
    "    sample = s.sample(n=5) #randomly sample 5 observations from this label \n",
    "    for j, s in enumerate(sample.values):\n",
    "        img = np.array(sample.iloc[j, :-1]).reshape(28,28) #reshape each observation back to 28x28 pixel matrix\n",
    "        plt_images.append(img) #append the images, used to visualizing \n",
    "        plt_labels.append(sample.iloc[j, -1]) #append the label \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 1152x864 with 50 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "#plot these sample images for each label \n",
    "f, ax = plt.subplots(5,10, figsize=(16,12))\n",
    "\n",
    "for i, img in enumerate(plt_images):\n",
    "    ax[i//10, i%10].imshow(img, cmap='Blues')\n",
    "    ax[i//10, i%10].axis('off')\n",
    "    ax[i//10, i%10].set_title(data_label[plt_labels[i]])\n",
    "plt.show()    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "After reading a lot of paper and documents about the image classifications, I find out that there are two most efficients machine learning alogrithms that can classify the image the best. First is CNN which is the convolutional neural networks. And the second one is to use Random forest to classify the images. \n",
    "\n",
    "Sample papers and documents are below that I refer: (There are also many others but just providing two samples here)\n",
    "\n",
    "https://medium.com/intro-to-artificial-intelligence/simple-image-classification-using-deep-learning-deep-learning-series-2-5e5b89e97926\n",
    "\n",
    "http://www.cs.huji.ac.il/~daphna/course/CoursePapers/bosch07a.pdf\n",
    "\n",
    "\n",
    "Therefore, after doing the through expolaratory analysis I decide to Use two algorithms: CNN and Random Forest to deal with this problem. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 2 Models "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The first algorithm that comes to my head is CNN. Before looking at this assignment, I already heard about how CNN works well on the image classifications. In order to further prove my previous experiences, I research a lot online and conclude some of my personal perspectives: (These conclusions are all cited below):\n",
    "\n",
    "1. the idea presented by Yann le cun in 1998: CNNs can be thought of automatic feature extractors from the image. If we just treat the images as vectors and do the machine learning algorithms, we may lose a lot of correlated information lie inside the matrix of the images. But CNN can solve that problem by effectively using adjacent pixel information to first make the image matrix simpler but remain the information of these matrix by using convolution and then use a dense layer to make the predictions. \n",
    "\n",
    "2. Deep learning yields less error than simple machine learning, implying higher accuracy. Deep learning is not to say only perceptrons with the multi-layers, it still has a big advantage is his freedom. Deep learning can be treated as an architecture that contains a large freedom so people can always find the best \"model\" which best fir the dataset. Deep learning just mimic how human brain works. \n",
    "\n",
    "3. Because CNN use multiple processing of the convolutional layer and the dense layer, it contains both the advantages of convolutional and deep neural network in the image classification. \n",
    "\n",
    "4. Since Steinkrau showed the value of using GPUs for machine learning in 2005: \"modern GPU computing and parallel computing methods have massively increased the ability to train CNN models, causing the rise of using CNN in image classification in the recent years.\"(cited Steinkrau,2005) Thus We can now train neural networks with very large dataset pretty efficiently with lower time cost and higher accuracy. \n",
    "\n",
    "Therefore, the first algorithm I decide to use for the image classification is the CNN. Not only because of its higher accuracy than other algorithms (https://medium.com/intuitionmachine/why-deep-learning-is-radically-different-from-machine-learning-945a4a65da4d) but also because how it's suitable for the image classification (as described above and https://www.quora.com/Why-does-the-convolutional-neural-network-have-higher-accuracy-precision-and-recall-rather-than-other-methods-like-SVM-KNN-and-Random-Forest/answer/Haohan-Wang and https://arxiv.org/abs/1702.07800) and how it cost not that much time. (I tried later, usually takes above 2-3 hours, approximately similar time with SVM but much higher accuracy.) "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Cited Reference:\n",
    "\n",
    "https://www.quora.com/Why-is-CNN-used-for-image-classification-and-why-not-other-algorithms\n",
    "\n",
    "https://prakhartechviz.blogspot.com/2019/01/image-classification-keras.html\n",
    "\n",
    "https://en.wikipedia.org/wiki/Kernel_(image_processing)#Convolution\n",
    "\n",
    "https://pdfs.semanticscholar.org/b8e3/613d60d374b53ec5b54112dfb68d0b52d82c.pdf\n",
    "\n",
    "https://web.stanford.edu/class/cs231a/prev_projects_2016/example_paper.pdf\n",
    "\n",
    "https://medium.com/intuitionmachine/why-deep-learning-is-radically-different-from-machine-learning-945a4a65da4d\n",
    "\n",
    "https://www.quora.com/Why-does-the-convolutional-neural-network-have-higher-accuracy-precision-and-recall-rather-than-other-methods-like-SVM-KNN-and-Random-Forest/answer/Haohan-Wang\n",
    "\n",
    "https://arxiv.org/abs/1702.07800"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The second model I decide to use is the random forest. The reasons that I decide to use the random forest is because:\n",
    "\n",
    "1. using random forests with appropriate parameters significantly reduce both the training cost and the test cost over SVM and at the same time, having a comparable performance which is similar accuracy. \n",
    "\n",
    "2. \"Random forests is an ensemble model which means that it uses the results from many different models to calculate the predicted label. Always the results getting from many models is better than only getting from one model\".(Dahinden 2009). \n",
    "\n",
    "3. Comparable results and accuracy with other machine learning models but not sensitive to the parameters chosen. And Easy to determine which parameters to be used(just used a cross validation can tune the parameter pretty well). \n",
    "\n",
    "4. Avoid overfitting and avoid correlations. \n",
    "\n",
    "5. The python code and library of random Forest is pretty easy to implement. \n",
    "\n",
    "Therefore, Even though I dont expect the accuracy of Random forest can exceeds the CNN, but I do believe that in other ways the random forest should be a better model than other machine learning algorithms because of its less cost, less correlation effects, not very sensitive to the parameters, easy to tune the parameters, easier to implement, etc. \n",
    "\n",
    "In other words, I believe that the deep learning (CNN) will yield the highest accuracy because the reasons and references I provide above, for the second Algorithm I personally believe other machine learning algorithms will yield similar accuracy. So I rather choose an algorithm with easy parameterization and less cost and can at the same time avoid correlations. \n",
    "\n",
    "Thus I decide to use the random forest as my second model. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Cited Reference:\n",
    "\n",
    "http://www.cs.huji.ac.il/~daphna/course/CoursePapers/bosch07a.pdf\n",
    "\n",
    "http://wgrass.media.osaka-cu.ac.jp/gisideas10/papers/04aa1f4a8beb619e7fe711c29b7b.pdf\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Data Splits (5 in the kaggle template) "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "I did the k-folds cross validation for my training data. And I set different K for CNN and random forest because their running time. \n",
    "\n",
    "Since CNN model spent a significantly larger running time than Random forest, I dont want my training model to run forever. Therefore, I set K=5 for the CNN and K = 10 for the random forest. \n",
    "\n",
    "Because the predictive classes in the training data are nearly evenly distributed, so I did not use the stratified K fold but only the simple K fold. For the CNN, I divided the training data to 5 equal pieces and run the cross validation (4 of 5 to be the training and the remaining one to be the validation). I output the average accuracy of 5 validation set. I think I did not overfit the training set because the each fold cross validation only train on 4 of 5 training set but not the left out validation set. So my final average accuracy is valid. \n",
    "\n",
    "I did the same thing for the random forest and the only difference is that I divide the training data to 10 sub datasets not 5. \n",
    "\n",
    "Code for CNN data splits:\n",
    "\n",
    "kf = KFold(n_splits=5,random_state=2019,shuffle=True)\n",
    "\n",
    "Code for RF data splits:\n",
    "\n",
    "kf_rf = KFold(n_splits=10,random_state=2022,shuffle=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "y = keras.utils.to_categorical(train_label.labels, 10) #alternate the dataset ready for CNN \n",
    "num_images = train.shape[0]\n",
    "x_as_array = train.values\n",
    "X = train.values.reshape(num_images, 28, 28, 1)# get ready the X for CNN \n",
    "kf = KFold(n_splits=5,random_state=2019,shuffle=True)# 5 folds split the data "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Training (CNN)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It's not an easy task to build a suitable deep learning model. Because there are so many choices and hyperparameters that can be used in the CNN, I have to make a lot of selections.\n",
    "\n",
    "For the CNN model, there are several parameters (not hyperparameters that I tuned later) I want to explain why I was using these instead of others:\n",
    "\n",
    "1. The structure of the neural network\n",
    "\n",
    "2. activation function \n",
    "\n",
    "3. kernel-initializer \n",
    "\n",
    "4. kernel size\n",
    "\n",
    "5. optimizer \n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "1. The structure of the neural network\n",
    "\n",
    "Based on the paper and referenced above, especially the article: https://medium.com/intro-to-artificial-intelligence/simple-image-classification-using-deep-learning-deep-learning-series-2-5e5b89e97926, I decide to use layers of Conv2D with a Maxpooling and final two dense layers(the last one is the softmax to get the prediction classes) to be the structure of my deep learning model.\n",
    "\n",
    "The other references of why I choose that structure is:\n",
    "\n",
    "https://towardsdatascience.com/the-4-convolutional-neural-network-models-that-can-classify-your-fashion-images-9fe7f3e5399d\n",
    "\n",
    "https://www.geeksforgeeks.org/image-classifier-using-cnn/\n",
    "\n",
    "https://developers.google.com/machine-learning/practica/image-classification/convolutional-neural-networks\n",
    "\n",
    "Based on these reference, I decide my neural network structure to be number of Conv2d, Maxpooling, dropout layers combine with Two Dense layers at the end. That was my basic structure of my neural network. \n",
    "\n",
    "2. Activation function\n",
    "\n",
    "The reason why I choose the activation = 'relu' is that the CNN applies a Rectified Linear Unit transformation to the convolved feature, in order to introduce the non-linearity. We know that if we dont add an appropriate activation function, the model will just like a linear regression which is not making sense. Relu: F(x) = max(0,x) returns all x for x>0 and 0 for x<0 and its purpose is to present non-linearity into the CNN model. the dataset we are using for the image classification needs first, non-linearity, and second, non-negative value. Therefore, relu is the most appropriate activation function for this dataset. \n",
    "\n",
    "3. Kernel-initializer\n",
    "\n",
    "I set kernel_initializer to be 'he_normal' basically inspired by: https://datascience.stackexchange.com/questions/13061/when-to-use-he-or-glorot-normal-initialization-over-uniform-init-and-what-are because I think that 'he_normal' is the most suitable initializer for our dataset.\n",
    "\n",
    "And of course the dimension of each plot of our data is 28x28, so thats why we set the input shape to be (28,28,1).\n",
    "\n",
    "4. kernel size\n",
    "\n",
    "I have explained why I use relu and he_normal above. I use (2,2) for MaxPooling2D((2, 2) because based on the articles I referenced above, (3,3) is too much for the 28x28 image classification(too many information will be ignored) and (1,1) is meaningless for the MaxPooling. So (2,2) is the only suitable hyperparameter for the MaxPooling and I no longer to tune it anymore.\n",
    "\n",
    "5. optimizer\n",
    "\n",
    "I choose optimizer = adam because I referenced by this article: https://blog.algorithmia.com/introduction-to-optimizers/. It is the combination of Momentum and RMSprop (combine their advantages) and it's very useful and currently very popular for the neural network.\n",
    "\n",
    "I also provide a running time below all of my training algorithms to compare their running times. \n",
    "\n",
    "### Remainder: all the running time below are the running time of 5-folds cross validation. So the actual running time of training will be much less than the running presented below. These are just for the running time comparisons between each models in order to tune the model. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Hyperparameter Selection (CNN) "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "After deciding all the parameters above, There are still several parameters in the CNN model that I have to tune, and I will try to tune these parameters below. Because of the long running time of the Neural network models, I cannot made a list and tune all of them at the same time it will cost very very long time to run, so I have to try to tune them one by one: \n",
    "\n",
    "1. Number of layers in the model \n",
    "\n",
    "2. Drop out coefficients \n",
    "\n",
    "3. coefficients in Conv2D\n",
    "\n",
    "4. coefficients in Dense Layer "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The first model I used is:\n",
    "\n",
    "model1 = Sequential()\n",
    "\n",
    "model1.add(Conv2D(32, kernel_size=(3, 3),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "\n",
    "model1.add(MaxPooling2D((2, 2)))\n",
    "\n",
    "model1.add(Dropout(0.25))\n",
    "\n",
    "model1.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "\n",
    "model1.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "\n",
    "model1.add(Dropout(0.25))\n",
    "\n",
    "model1.add(Flatten())\n",
    "\n",
    "model1.add(Dense(64, activation='relu'))\n",
    "\n",
    "model1.add(Dropout(0.3))\n",
    "\n",
    "model1.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model1.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])\n",
    "\n",
    "The average accuracy is about 0.945 and running time is slightly less than 3 hours. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 131,
   "metadata": {},
   "outputs": [],
   "source": [
    "model1 = Sequential()# define the model \n",
    "\n",
    "#first add 32 Conv layer \n",
    "model1.add(Conv2D(32, kernel_size=(3, 3),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "#Add a maxpooling layer\n",
    "model1.add(MaxPooling2D((2, 2)))\n",
    "# Add dropout term to avoid overfitting\n",
    "model1.add(Dropout(0.25))\n",
    "# Then add 64 conv layer \n",
    "model1.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "# Add a Maxpooling\n",
    "model1.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "#Add dropout term to avoid overfitting\n",
    "model1.add(Dropout(0.25))\n",
    "#Flatten to prepare for the dense layer\n",
    "model1.add(Flatten())\n",
    "#Add a 64 layer dense layer\n",
    "model1.add(Dense(64, activation='relu'))\n",
    "#Add dropout term to avoid overfitting\n",
    "model1.add(Dropout(0.3))\n",
    "# use softmax to classify to each labels \n",
    "model1.add(Dense(10, activation='softmax'))\n",
    "\n",
    "# define the loss, optimizer and metrics. \n",
    "model1.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 141,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 6h 50min 37s, sys: 54min 28s, total: 7h 45min 5s\n",
      "Wall time: 2h 49min 22s\n"
     ]
    }
   ],
   "source": [
    "%%time #to calculate the time used \n",
    "\n",
    "overall_accu1 = []\n",
    "for train, test in kf.split(X,y):\n",
    "    # transform train and valid x,y to numpy array\n",
    "    train_x = np.array(X)[train]\n",
    "    train_y = np.array(y)[train]\n",
    "    valid_x = np.array(X)[test]\n",
    "    valid_y = np.array(y)[test]\n",
    "    # fit the model \n",
    "    train_model1 = model1.fit(train_x, train_y,\n",
    "                  batch_size=128,\n",
    "                  epochs=50,\n",
    "                  verbose=0,\n",
    "                  )\n",
    "    # get the validation accuracy for each fold \n",
    "    acc1 = train_model1.history['val_acc'][-1]\n",
    "    overall_accu1.append(acc1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 133,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.9451272727446123"
      ]
     },
     "execution_count": 133,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sum(overall_accu1)/5"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This is a decent accuracy and running time but I still want to tune the parameter to see if it can work better. I keep all other things equal and set the first dense layer to be 128: \n",
    "\n",
    "model11 = Sequential()\n",
    "\n",
    "model11.add(Conv2D(32, kernel_size=(3, 3),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "\n",
    "model11.add(MaxPooling2D((2, 2)))\n",
    "\n",
    "model11.add(Dropout(0.25))\n",
    "\n",
    "model11.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "\n",
    "model11.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "\n",
    "model11.add(Dropout(0.25))\n",
    "\n",
    "model11.add(Flatten())\n",
    "\n",
    "model11.add(Dense(128, activation='relu'))\n",
    "\n",
    "model11.add(Dropout(0.3))\n",
    "\n",
    "model11.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model11.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])\n",
    "              \n",
    "Now the new accuracy is about 0.959 and running time still slightly less than 3 hours. Implying that increasing Dense layer can improve the performance of the model. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 134,
   "metadata": {},
   "outputs": [],
   "source": [
    "#basically same code as above\n",
    "model11 = Sequential()\n",
    "\n",
    "model11.add(Conv2D(32, kernel_size=(3, 3),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "model11.add(MaxPooling2D((2, 2)))\n",
    "model11.add(Dropout(0.25))\n",
    "model11.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "model11.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model11.add(Dropout(0.25))\n",
    "model11.add(Flatten())\n",
    "model11.add(Dense(128, activation='relu'))\n",
    "model11.add(Dropout(0.3))\n",
    "model11.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model11.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 136,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 6h 58min 33s, sys: 56min 31s, total: 7h 55min 5s\n",
      "Wall time: 2h 57min 48s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "\n",
    "overall_accu11 = []\n",
    "for train, test in kf.split(X,y):\n",
    "    train_x = np.array(X)[train]\n",
    "    train_y = np.array(y)[train]\n",
    "    valid_x = np.array(X)[test]\n",
    "    valid_y = np.array(y)[test]\n",
    "    train_model11 = model11.fit(train_x, train_y,\n",
    "                  batch_size=128,\n",
    "                  epochs=50,\n",
    "                  verbose=0,\n",
    "                  validation_data=(valid_x, valid_y))\n",
    "    acc11 = train_model11.history['val_acc'][-1]\n",
    "    overall_accu11.append(acc11)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 137,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.959199999852614"
      ]
     },
     "execution_count": 137,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sum(overall_accu11)/5"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Then I tried to tune the kernel size and add two more conv layers into the model to see what will happen: \n",
    "\n",
    "model111 = Sequential()\n",
    "\n",
    "model111.add(Conv2D(32, kernel_size=(5, 5),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "\n",
    "model111.add(Conv2D(32, kernel_size=(5, 5),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "\n",
    "model111.add(MaxPooling2D((2, 2)))\n",
    "\n",
    "model111.add(Dropout(0.25))\n",
    "\n",
    "model111.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "\n",
    "model111.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "\n",
    "model111.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "\n",
    "model111.add(Dropout(0.25))\n",
    "\n",
    "model111.add(Flatten())\n",
    "\n",
    "model111.add(Dense(128, activation='relu'))\n",
    "\n",
    "model111.add(Dropout(0.3))\n",
    "\n",
    "model111.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model111.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])\n",
    "              \n",
    "The resulting accuracy did not improve, which is about 0.9537 but the running time is significantly larger, which is more than 12 hours. So I conclude that increasing kernel size and add more layers is meaningless and too time costly. So I decide just to set kernel_size to be (3,3) and keep the original structure. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 138,
   "metadata": {},
   "outputs": [],
   "source": [
    "#basically same code as above\n",
    "model111 = Sequential()\n",
    "\n",
    "#add two consecutive 32 Conv2D layer \n",
    "model111.add(Conv2D(32, kernel_size=(5, 5),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "model111.add(Conv2D(32, kernel_size=(5, 5),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "model111.add(MaxPooling2D((2, 2)))\n",
    "model111.add(Dropout(0.25))\n",
    "#add two consecutive 64 Conv2D layer \n",
    "model111.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "model111.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "model111.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model111.add(Dropout(0.25))\n",
    "model111.add(Flatten())\n",
    "model111.add(Dense(128, activation='relu'))\n",
    "model111.add(Dropout(0.3))\n",
    "model111.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model111.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 139,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 1d 4min 5s, sys: 4h 37min 44s, total: 1d 4h 41min 49s\n",
      "Wall time: 12h 18min 11s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "\n",
    "overall_accu111 = []\n",
    "for train, test in kf.split(X,y):\n",
    "    train_x = np.array(X)[train]\n",
    "    train_y = np.array(y)[train]\n",
    "    valid_x = np.array(X)[test]\n",
    "    valid_y = np.array(y)[test]\n",
    "    train_model111 = model111.fit(train_x, train_y,\n",
    "                  batch_size=128,\n",
    "                  epochs=50,\n",
    "                  verbose=0,\n",
    "                  validation_data=(valid_x, valid_y))\n",
    "    acc111 = train_model111.history['val_acc'][-1]\n",
    "    overall_accu111.append(acc111)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 140,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.9537454546755011"
      ]
     },
     "execution_count": 140,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sum(overall_accu111)/5"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Then I tried to tune the convolutional layer. I tried to add one more convolutional layer: Conv2D(16, kernel_size=(3, 3),activation='relu',kernel_initializer='he_normal',input_shape=(28, 28, 1)) to the first model I tried and to see whether the performance will be improved:\n",
    "\n",
    "model2 = Sequential()\n",
    "\n",
    "model2.add(Conv2D(16, kernel_size=(3, 3),activation='relu',kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "\n",
    "model2.add(MaxPooling2D((2, 2)))\n",
    "\n",
    "model2.add(Dropout(0.25))\n",
    "\n",
    "model2.add(Conv2D(32, kernel_size=(3, 3), activation='relu'))\n",
    "\n",
    "model2.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "\n",
    "model2.add(Dropout(0.25))\n",
    "\n",
    "model2.add(Conv2D(64, (3, 3), activation='relu'))\n",
    "\n",
    "model2.add(Dropout(0.4))\n",
    "\n",
    "model2.add(Flatten())\n",
    "\n",
    "model2.add(Dense(64, activation='relu'))\n",
    "\n",
    "model2.add(Dropout(0.3))\n",
    "\n",
    "model2.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model2.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])\n",
    "              \n",
    "And I discovered that the accuracy actually largely decrease. So that's not a good way to build the model. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 142,
   "metadata": {},
   "outputs": [],
   "source": [
    "#basically similar code as above \n",
    "model2 = Sequential()\n",
    "\n",
    "model2.add(Conv2D(16, kernel_size=(3, 3),activation='relu',kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "model2.add(MaxPooling2D((2, 2)))\n",
    "model2.add(Dropout(0.25))\n",
    "model2.add(Conv2D(32, kernel_size=(3, 3), activation='relu'))\n",
    "model2.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model2.add(Dropout(0.25))\n",
    "model2.add(Conv2D(64, (3, 3), activation='relu'))\n",
    "model2.add(Dropout(0.4))\n",
    "model2.add(Flatten())\n",
    "model2.add(Dense(64, activation='relu'))\n",
    "model2.add(Dropout(0.3))\n",
    "model2.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model2.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 143,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 3h 32min 38s, sys: 56min 16s, total: 4h 28min 54s\n",
      "Wall time: 1h 39min 25s\n"
     ]
    }
   ],
   "source": [
    "%%time \n",
    "\n",
    "overall_accu2 = []\n",
    "for train, test in kf.split(X,y):\n",
    "    train_x = np.array(X)[train]\n",
    "    train_y = np.array(y)[train]\n",
    "    valid_x = np.array(X)[test]\n",
    "    valid_y = np.array(y)[test]\n",
    "    train_model2 = model2.fit(train_x, train_y,\n",
    "                  batch_size=128,\n",
    "                  epochs=50,\n",
    "                  verbose=0,\n",
    "                  validation_data=(valid_x, valid_y))\n",
    "    acc2 = train_model2.history['val_acc'][-1]\n",
    "    overall_accu2.append(acc2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 144,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.9199272725625471"
      ]
     },
     "execution_count": 144,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sum(overall_accu2)/5"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Then I tried to add the number of neurons in each conv layer by multiplying by 2 to see how it works:\n",
    "\n",
    "model = Sequential()\n",
    "\n",
    "model.add(Conv2D(32, kernel_size=(3, 3),activation='relu',kernel_initializer='he_normal',input_shape=(28, 28, 1))\n",
    "\n",
    "model.add(MaxPooling2D((2, 2)))\n",
    "\n",
    "model.add(Dropout(0.25))\n",
    "\n",
    "model.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "\n",
    "model.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "\n",
    "model.add(Dropout(0.25))\n",
    "\n",
    "model.add(Conv2D(128, (3, 3), activation='relu'))\n",
    "\n",
    "model.add(Dropout(0.3))\n",
    "\n",
    "model.add(Flatten())\n",
    "\n",
    "model.add(Dense(128, activation='relu'))\n",
    "\n",
    "model.add(Dropout(0.3))\n",
    "\n",
    "model.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])\n",
    "              \n",
    "The running time is still around 3 hours (actually more than 3 hours) but the accuracy is 0.948 (not anything improving from the second model I used. Since the only difference between this model and my second model is I add a 128 conv layer into the model. So I concluded it's meaningless to add any further conv layers to my model. (adding both 16 and 128 does not improve the performance.) "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 145,
   "metadata": {},
   "outputs": [],
   "source": [
    "#basically similar code as above \n",
    "model = Sequential()\n",
    "\n",
    "model.add(Conv2D(32, kernel_size=(3, 3),activation='relu',kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "model.add(MaxPooling2D((2, 2)))\n",
    "model.add(Dropout(0.25))\n",
    "model.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "model.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model.add(Dropout(0.25))\n",
    "model.add(Conv2D(128, (3, 3), activation='relu'))\n",
    "model.add(Dropout(0.3))\n",
    "model.add(Flatten())\n",
    "model.add(Dense(128, activation='relu'))\n",
    "model.add(Dropout(0.3))\n",
    "model.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 146,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 7h 41min 35s, sys: 1h 39min 46s, total: 9h 21min 21s\n",
      "Wall time: 3h 15min 39s\n"
     ]
    }
   ],
   "source": [
    "#basically similar code as above \n",
    "%%time \n",
    "\n",
    "overall_accu = []\n",
    "for train, test in kf.split(X,y):\n",
    "    train_x = np.array(X)[train]\n",
    "    train_y = np.array(y)[train]\n",
    "    valid_x = np.array(X)[test]\n",
    "    valid_y = np.array(y)[test]\n",
    "    train_model = model.fit(train_x, train_y,\n",
    "                  batch_size=128,\n",
    "                  epochs=50,\n",
    "                  verbose=0,\n",
    "                  validation_data=(valid_x, valid_y))\n",
    "    acc = train_model.history['val_acc'][-1]\n",
    "    overall_accu.append(acc)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 147,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.9483818182078275"
      ]
     },
     "execution_count": 147,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sum(overall_accu)/5"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "So After all of these tryings, I decide to use my second model to be as my currently bese model. I have decided the number of the layers, the structure, the parameters in the Conv2D and Maxpooling, then I begin to tune the Dropout terms. \n",
    "\n",
    "I tried to tune the dropout term for the 128 dense layer from 0.3 to 0.25 to see if there's any difference:\n",
    "\n",
    "model3 = Sequential()\n",
    "\n",
    "model3.add(Conv2D(32, kernel_size=(3, 3),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "\n",
    "model3.add(MaxPooling2D((2, 2)))\n",
    "\n",
    "model3.add(Dropout(0.25))\n",
    "\n",
    "model3.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "\n",
    "model3.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "\n",
    "model3.add(Dropout(0.25))\n",
    "\n",
    "model3.add(Flatten())\n",
    "\n",
    "model3.add(Dense(128, activation='relu'))\n",
    "\n",
    "model3.add(Dropout(0.25))\n",
    "\n",
    "model3.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model3.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])\n",
    "\n",
    "The running time and the accuracy is very very similar to my second model therefore I think that dropout term does not make a large difference on the performance. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 148,
   "metadata": {},
   "outputs": [],
   "source": [
    "#basically similar code as above \n",
    "model3 = Sequential()\n",
    "\n",
    "model3.add(Conv2D(32, kernel_size=(3, 3),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "model3.add(MaxPooling2D((2, 2)))\n",
    "model3.add(Dropout(0.25))\n",
    "model3.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "model3.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model3.add(Dropout(0.25))\n",
    "model3.add(Flatten())\n",
    "model3.add(Dense(128, activation='relu'))\n",
    "model3.add(Dropout(0.25))\n",
    "model3.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model3.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 150,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 6h 58min 52s, sys: 57min 21s, total: 7h 56min 13s\n",
      "Wall time: 2h 47min 17s\n"
     ]
    }
   ],
   "source": [
    "#basically similar code as above \n",
    "%%time \n",
    "\n",
    "overall_accu3 = []\n",
    "for train, test in kf.split(X,y):\n",
    "    train_x = np.array(X)[train]\n",
    "    train_y = np.array(y)[train]\n",
    "    valid_x = np.array(X)[test]\n",
    "    valid_y = np.array(y)[test]\n",
    "    train_model3 = model3.fit(train_x, train_y,\n",
    "                  batch_size=128,\n",
    "                  epochs=50,\n",
    "                  verbose=0,\n",
    "                  validation_data=(valid_x, valid_y))\n",
    "    acc3 = train_model3.history['val_acc'][-1]\n",
    "    overall_accu3.append(acc3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 151,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.9579090908830816"
      ]
     },
     "execution_count": 151,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sum(overall_accu3)/5"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "After deciding all of these, I made a last move on the dense layers. I tune the dense layers from 128 to be 256 and to see what will happen: (will it be a large improvement on the accuracy?)\n",
    "\n",
    "model3_2 = Sequential()\n",
    "\n",
    "model3_2.add(Conv2D(32, kernel_size=(3, 3),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "\n",
    "model3_2.add(MaxPooling2D((2, 2)))\n",
    "\n",
    "model3_2.add(Dropout(0.25))\n",
    "\n",
    "model3_2.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "\n",
    "model3_2.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "\n",
    "model3_2.add(Dropout(0.25))\n",
    "\n",
    "model3_2.add(Flatten())\n",
    "\n",
    "model3_2.add(Dense(256, activation='relu'))\n",
    "\n",
    "model3_2.add(Dropout(0.25))\n",
    "\n",
    "model3_2.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model3_2.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])\n",
    "        \n",
    "It turns out that it will have a large improvement on the accuracy: the accuracy being larger than 0.965 and not cost very much running time. So I find out that adding dense layer may be the best way to improve the performance of the model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "#basically similar code as above \n",
    "model3_2 = Sequential()\n",
    "\n",
    "model3_2.add(Conv2D(32, kernel_size=(3, 3),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "model3_2.add(MaxPooling2D((2, 2)))\n",
    "model3_2.add(Dropout(0.25))\n",
    "model3_2.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "model3_2.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model3_2.add(Dropout(0.25))\n",
    "model3_2.add(Flatten())\n",
    "model3_2.add(Dense(256, activation='relu'))\n",
    "model3_2.add(Dropout(0.25))\n",
    "model3_2.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model3_2.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 7h 18min 50s, sys: 1h 34min 9s, total: 8h 52min 59s\n",
      "Wall time: 3h 31min 3s\n"
     ]
    }
   ],
   "source": [
    "#basically similar code as above \n",
    "%%time \n",
    "\n",
    "overall_accu3_2 = []\n",
    "for train, test in kf.split(X,y):\n",
    "    train_x = np.array(X)[train]\n",
    "    train_y = np.array(y)[train]\n",
    "    valid_x = np.array(X)[test]\n",
    "    valid_y = np.array(y)[test]\n",
    "    train_model3_2 = model3_2.fit(train_x, train_y,\n",
    "                  batch_size=128,\n",
    "                  epochs=50,\n",
    "                  verbose=0,\n",
    "                  validation_data=(valid_x, valid_y))\n",
    "    acc3_2 = train_model3_2.history['val_acc'][-1]\n",
    "    overall_accu3_2.append(acc3_2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.967672727281397"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sum(overall_accu3_2)/5"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "I discover increasing the number of dense layer maybe a best way to improve the model performance, so I switch dense layer from 256 to 512 and see what happens: \n",
    "\n",
    "model4 = Sequential()\n",
    "\n",
    "model4.add(Conv2D(32, kernel_size=(3, 3),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "\n",
    "model4.add(MaxPooling2D((2, 2)))\n",
    "\n",
    "model4.add(Dropout(0.25))\n",
    "\n",
    "model4.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "\n",
    "model4.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "\n",
    "model4.add(Dropout(0.25))\n",
    "\n",
    "model4.add(Flatten())\n",
    "\n",
    "model4.add(Dense(512, activation='relu'))\n",
    "\n",
    "model4.add(Dropout(0.5))\n",
    "\n",
    "model4.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model4.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])\n",
    "              \n",
    "it turns out that the accuracy keep increasing to 0.97+. And the running time does not significantly increases. Total time is nearly the same but my conputer shut down for a moment. So the real running time is still about 3 hours.\n",
    "\n",
    "For here I add my dropout term to be 0.5 because higher dense layer implies larger probability to be overfitting so I add a higher dropout term to avoid overfitting. For here I did not turn much more about the dropout term because i think it's not that useful based on the previous runnings. 0.45,0.5,0.55 will not make a large difference. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "#basically similar code as above \n",
    "model4 = Sequential()\n",
    "\n",
    "model4.add(Conv2D(32, kernel_size=(3, 3),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "model4.add(MaxPooling2D((2, 2)))\n",
    "model4.add(Dropout(0.25))\n",
    "model4.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "model4.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model4.add(Dropout(0.25))\n",
    "model4.add(Flatten())\n",
    "model4.add(Dense(512, activation='relu'))\n",
    "model4.add(Dropout(0.5))\n",
    "model4.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model4.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 7h 53min 36s, sys: 1h 34min 43s, total: 9h 28min 20s\n",
      "Wall time: 9h 33min 53s\n"
     ]
    }
   ],
   "source": [
    "#basically similar code as above \n",
    "%%time \n",
    "\n",
    "overall_accu4 = []\n",
    "for train, test in kf.split(X,y):\n",
    "    train_x = np.array(X)[train]\n",
    "    train_y = np.array(y)[train]\n",
    "    valid_x = np.array(X)[test]\n",
    "    valid_y = np.array(y)[test]\n",
    "    train_model4 = model4.fit(train_x, train_y,\n",
    "                  batch_size=128,\n",
    "                  epochs=50,\n",
    "                  verbose=0,\n",
    "                  validation_data=(valid_x, valid_y))\n",
    "    acc4 = train_model4.history['val_acc'][-1]\n",
    "    overall_accu4.append(acc4)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.9701454546581616"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sum(overall_accu4)/5"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Then I made a last try to tune the number of dense layers to 1028, the accuracy improves a little bit but costs much more time(about two more hour). So I decide to use dense layer = 512 for this dataset. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "#basically similar code as above \n",
    "model6 = Sequential()\n",
    "\n",
    "model6.add(Conv2D(32, kernel_size=(3, 3),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "model6.add(MaxPooling2D((2, 2)))\n",
    "model6.add(Dropout(0.25))\n",
    "model6.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "model6.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model6.add(Dropout(0.25))\n",
    "model6.add(Flatten())\n",
    "model6.add(Dense(1028, activation='relu'))\n",
    "model6.add(Dropout(0.5))\n",
    "model6.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model6.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 9h 21min 35s, sys: 1h 54min 39s, total: 11h 16min 14s\n",
      "Wall time: 15h 17min 17s\n"
     ]
    }
   ],
   "source": [
    "#basically similar code as above \n",
    "%%time \n",
    "\n",
    "overall_accu6 = []\n",
    "for train, test in kf.split(X,y):\n",
    "    train_x = np.array(X)[train]\n",
    "    train_y = np.array(y)[train]\n",
    "    valid_x = np.array(X)[test]\n",
    "    valid_y = np.array(y)[test]\n",
    "    train_model6 = model6.fit(train_x, train_y,\n",
    "                  batch_size=128,\n",
    "                  epochs=50,\n",
    "                  verbose=0,\n",
    "                  validation_data=(valid_x, valid_y))\n",
    "    acc6 = train_model6.history['val_acc'][-1]\n",
    "    overall_accu6.append(acc6)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.9730000000173396"
      ]
     },
     "execution_count": 24,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sum(overall_accu6)/5"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "At last I add the BatchNormalization for each layer to see if there will be any improvements. However, the accuracy decreases. And it costs much much more time to run the alrogithm. \n",
    "\n",
    "Therefore, I decide not to add the BatchNormalization term. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "#basically similar code as above \n",
    "model5 = Sequential()\n",
    "\n",
    "model5.add(Conv2D(32, kernel_size=(3, 3),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "model5.add(BatchNormalization())\n",
    "model5.add(MaxPooling2D((2, 2)))\n",
    "model5.add(Dropout(0.25))\n",
    "model5.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "model5.add(BatchNormalization())\n",
    "model5.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model5.add(Dropout(0.25))\n",
    "model5.add(Flatten())\n",
    "model5.add(Dense(512, activation='relu'))\n",
    "model5.add(BatchNormalization())\n",
    "model5.add(Dropout(0.5))\n",
    "model5.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model5.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 19h 40min 23s, sys: 3h 16min 4s, total: 22h 56min 28s\n",
      "Wall time: 1d 10h 14min 2s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "#basically similar code as above \n",
    " \n",
    "overall_accu5 = []\n",
    "for train, test in kf.split(X,y):\n",
    "    train_x = np.array(X)[train]\n",
    "    train_y = np.array(y)[train]\n",
    "    valid_x = np.array(X)[test]\n",
    "    valid_y = np.array(y)[test]\n",
    "    train_model5 = model5.fit(train_x, train_y,\n",
    "                  batch_size=128,\n",
    "                  epochs=50,\n",
    "                  verbose=0,\n",
    "                  validation_data=(valid_x, valid_y))\n",
    "    acc5 = train_model5.history['val_acc'][-1]\n",
    "    overall_accu5.append(acc5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.9679999999566512"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sum(overall_accu5)/5"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "At last, I decide my final CNN model to be:\n",
    "\n",
    "model4 = Sequential()\n",
    "\n",
    "model4.add(Conv2D(32, kernel_size=(3, 3),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "\n",
    "model4.add(MaxPooling2D((2, 2)))\n",
    "\n",
    "model4.add(Dropout(0.25))\n",
    "\n",
    "model4.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "\n",
    "model4.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "\n",
    "model4.add(Dropout(0.25))\n",
    "\n",
    "model4.add(Flatten())\n",
    "\n",
    "model4.add(Dense(512, activation='relu'))\n",
    "\n",
    "model4.add(Dropout(0.5))\n",
    "\n",
    "model4.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model4.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 1h 52min 2s, sys: 23min 3s, total: 2h 15min 6s\n",
      "Wall time: 51min 25s\n"
     ]
    }
   ],
   "source": [
    "%%time \n",
    "\n",
    "train_model4 = model4.fit(X, y,\n",
    "                  batch_size=128,\n",
    "                  epochs=50,\n",
    "                  verbose=0)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This final model takes 51min to train the whole training dataset and I think it's an appropriate time. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "After all of these trainings (tuning hyperparameters), I discover that the most important hyperparameter may be the number of layers in the dense. \n",
    "\n",
    "Therefore, in order to present a more clear picture on how the number of dense layers will affect the accuracy (performance of the model), I made a plot: "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# append all cross validation accuracy to a single list \n",
    "accus = np.array([overall_accu2,overall_accu,sum(overall_accu3_2)/5,sum(overall_accu4)/5,sum(overall_accu6)/5]) \n",
    "# append the corresponding dense layer number\n",
    "dense = np.array([64,128,256,512,1028])\n",
    "# plot the plot \n",
    "plt.plot(dense,accus)\n",
    "plt.ylabel('Accuracy')\n",
    "plt.xlabel('Dense layers')\n",
    "plt.title('Cross Validation accuracy vs. dense layers')\n",
    "pass"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Training (Random Forest) "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "There are several parameters in the Random Forest that I want to explain why I was using these:\n",
    "\n",
    "1. criterion (Gini and Entropy)\n",
    "\n",
    "2. max_features\n",
    "\n",
    "3. bootstrap\n",
    "\n",
    "4. n-jobs "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "1. Criterion:\n",
    "\n",
    "\"Gini measurement is the probability of a random sample being classified incorrectly if we randomly pick a label according to the distribution in a branch.\"\n",
    "\n",
    "\"Entropy is a measurement of information (or rather lack thereof). We calculate the information gain by making a split. Which is the difference in entripies. This measures how you reduce the uncertainty about the label.\"\n",
    "\n",
    "Above two sentences is reference to: https://www.quora.com/What-is-difference-between-Gini-Impurity-and-Entropy-in-Decision-Tree. I think it's a very good explanations for these two contents and it's what we learned the definition of these two in the class. So I copy them here. (Cited)\n",
    "\n",
    "For here I use the Gini (which is the default of the random forest function here), because for my personal opinion, Gini works better on continuous variables and Entropy is better for discrete attributes. And Gini tends to minimize misclassification and Gini usually run faster.\n",
    "\n",
    "2. max_features\n",
    "\n",
    "Based on the class note, The best maximum features for each bootstrapping will be the square root of the number of features. Thus I choose the sqrt max_features based on what we learned in class. \n",
    "\n",
    "3. bootstrap\n",
    "\n",
    "I set true for this parameter because it can add more randomness to our model in order to avoid overfitting and correlation errors.\n",
    "\n",
    "4. n-jobs\n",
    "\n",
    "I set this paramter to -1 so we use all processors to the number of jobs to run in parallel for both fit and predict. It can help our algorihm to run faster. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Hyperparameter Selection (Random Forest) "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In this section I will tune the parameter of the Random Forest. Based on the class notes, class readings, and homeworks, and at the same time avoid long-time running, I decide only to tune the n_estimators, which is the number of trees and max_depth, which is the depth of each trees. \n",
    "\n",
    "I use the cross validation to tune the hyperparameter. Unlike the CNN which I divide the training into 5 pieces, this time I divide the training into 10 pieces. I tested n_estimators from [50,100,200,400,700,1000,1500,2000,3000,5000] and max_depth from [4,5,6,8]. \n",
    "\n",
    "The whole cross validation tuning process takes more than a day, it's especially slower when the number of trees and max_depth getting larger. \n",
    "\n",
    "The result can be seen below, it turns out that the number of trees did not affect the accuracy very much, max_depth turns out to be a much important hyperparameter. The highest accuracy occurs at max_depth = 8 and n_estimators = 5000. It shows the trend that higher max_depth resulting higher accuracy. But much lower than CNN. \n",
    "\n",
    "I did not continue tune the parameter for the random forest because obviously when the max_depth and n_estimators get larger the running time of random forest will be very much like the Final CNN model I defined above. \n",
    "\n",
    "However, the accuracy of Random Forest model still much lower than CNN's. Therefore, I can conclude that at similar time, CNN's accuracy is much higher than the Random Forest. Therefore, I choose CNN as my final model decision. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [],
   "source": [
    "#prepare the dataset \n",
    "train = np.load('train_images.npy')\n",
    "valid = np.load('test_images.npy')\n",
    "train_label = np.load('train_labels.npy')\n",
    "train_rf = pd.DataFrame(train)\n",
    "valid_rf = pd.DataFrame(valid)\n",
    "train_y_rf = pd.DataFrame(train_label)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "metadata": {},
   "outputs": [],
   "source": [
    "kf_rf = KFold(n_splits=10,random_state=2022,shuffle=True) # set the 10 folds cross validation\n",
    "l1 = [50,100,200,400,700,1000,1500,2000,3000,5000] # set the number of trees for tuning parameter\n",
    "l2 = [4,5,6,8] # set the max depth of trees for tuning parameter "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 173,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 2d 16h 54min 2s, sys: 25min 37s, total: 2d 17h 19min 40s\n",
      "Wall time: 1d 1h 12min 56s\n"
     ]
    }
   ],
   "source": [
    "%%time \n",
    "\n",
    "overall_accu_rf = []\n",
    "for i in l2:\n",
    "    for j in l1:\n",
    "        #for different max depth and different number of trees \n",
    "        tmp_acc = []\n",
    "        # define the randomforest classifier\n",
    "        rf = RandomForestClassifier(n_estimators=j, max_depth=i,n_jobs=-1,random_state=20192019)\n",
    "        for train, test in kf_rf.split(train_rf,train_label):\n",
    "            # change the data to numpy arrays\n",
    "            train_x = np.array(train_rf)[train]\n",
    "            train_y = np.array(train_label)[train]\n",
    "            valid_x = np.array(train_rf)[test]\n",
    "            valid_y = np.array(train_label)[test]\n",
    "            # fit the training data\n",
    "            rf.fit(train_x,train_y)\n",
    "            # pred the validation set \n",
    "            pred = rf.predict(valid_x)\n",
    "            acc_rf = accuracy_score(valid_y, pred)\n",
    "            tmp_acc.append(acc_rf)\n",
    "        overall_accu_rf.append([i,j,sum(tmp_acc)/10])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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cAYOHMiIESO46667eOqpp+jSpQvHHHMMkydPZrvttuOLL75g/vz5/OIXv+Cuu+6q7J/queee47zzzmP58uWcddZZPPLIIzz++OOUlpYyfvz4ys4L99hjD373u99x8MEHM3ToUObMmUNR0eZGJP0pL49efPFFjjrqKFauXJlT/sLCQjp06EBhYSHr169n48aNdVpvu3btKgNHcXExRUVFFBYWUlhYWDlcU1qmaUCNO/RsacnxZF81jc3MagwmmXaoTZWZ1fpzzZRW24ON2gaXugSj+q7D3SsDoVf7lObcl53pO1xRUUHfvn0pLy+na9eudO7cuXK4tLSUjz76iKuuuopPP/2U9957jw8++IBdd92VE088kfHjx3PZZZdlXO4777zD7rvvDsDuu+9OeXk5S5cuZfHixUyZMoWNGzdy9NFH07FjR/bYYw82bdpEv379eOWVV9h+++0pLy+v/A326dOH8vJyvvSlL/HWW29V+T536tSJIUOG0LZtW/r27cvKlSvp0aNHvbYVKFhk9cQTT3DcccfRpUsX7rvvPrbddtsqR/+ZhouLi6sso7y8vMqZR+rsozbDuRxJpnbkGzZsqDY/QHFxcWXwSQ0XFxfToUOHLdLSx3NNyzRuZpSXl1ce0VdUVFQZzmda6kiwLgG2IfNnW0ZddvKtSeVR8V731XtZ2wBdMqSvXLmSJUuWsNdee/H8889TVlbGXnvtRbdu3ejZsydz587lu9/9bmVHgj179mSPPfbgvPPO46qrruLRRx/N2JHggAED2LhxIwMHDuTtt9+mb9++HHDAAYwaNWqLjgTnzJlD//79efzxxznwwAPp2bMnr7/+Ov3796dDhw507tyZ/v378+GHH7Js2TJ69+5duZ6DDjqIl19+ma9+9assW7asstfc+lKwqMGUKVM4/fTT2XPPPfnHP/5B9+7d67ScwsJCOnbsSMeOHRu4hCKytZWUlHDaaafx6KOPVqalOhIcP348o0aNYvHixey9995V5pswYQInn3wyO+64Y5WOBM8880xuu+023J3rr78e2NyRYLt27Zg2bRobNmzg0ksvZfTo0dx44401lu/iiy/m9NNP55NPPuHMM8+kTZs2DVJvXbOoxm9+8xvOP/98hgwZwqOPPkrnzp0bbNkiUjfqSLD+dM2igVRUVHDxxRfzq1/9ihNOOIH777+fdu3aNXax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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "acc_plt = []\n",
    "n_tree = []\n",
    "acc_plt4 = []\n",
    "acc_plt5 = []\n",
    "acc_plt6 = []\n",
    "acc_plt8 = []\n",
    "n_tree4 = []\n",
    "n_tree5 = []\n",
    "n_tree6 = []\n",
    "n_tree8 = []\n",
    "labels = [4,5,6,8]\n",
    "colors = [\"black\",\"yellow\",\"orange\",\"purple\"] #define the different color for different max depth \n",
    "for n in range(40):\n",
    "    #the first 10 are max_depth 4's accuracy\n",
    "    if n < 10:\n",
    "        acc_plt4.append(overall_accu_rf[n][2])\n",
    "        n_tree4.append(overall_accu_rf[n][1])\n",
    "    #the 11-20 are max_depth 5's accuracy\n",
    "    elif n < 20 and n >= 10:\n",
    "        acc_plt5.append(overall_accu_rf[n][2])\n",
    "        n_tree5.append(overall_accu_rf[n][1])\n",
    "    #the 21-30 are max_depth 5's accuracy\n",
    "    elif n < 30 and n >= 20:\n",
    "        acc_plt6.append(overall_accu_rf[n][2])\n",
    "        n_tree6.append(overall_accu_rf[n][1])\n",
    "    #the 31-40 are max_depth 5's accuracy\n",
    "    elif n < 40 and n >= 30:\n",
    "        acc_plt8.append(overall_accu_rf[n][2])\n",
    "        n_tree8.append(overall_accu_rf[n][1])\n",
    "#append the accuracy and n_tree lists to the overall lists use for visualization \n",
    "acc_plt.append(acc_plt4)\n",
    "acc_plt.append(acc_plt5)\n",
    "acc_plt.append(acc_plt6)\n",
    "acc_plt.append(acc_plt8)\n",
    "n_tree.append(n_tree4)\n",
    "n_tree.append(n_tree5)\n",
    "n_tree.append(n_tree6)\n",
    "n_tree.append(n_tree8)\n",
    "for i, color in zip(range(4),colors):\n",
    "    plt.plot(n_tree[i], acc_plt[i], color=colors[i],label='max_depth {0}' #plot the different max_depth's accuracy\n",
    "    ''.format(labels[i])) #differentiated by the color \n",
    "plt.legend(loc=\"lower right\",prop={'size': 8})\n",
    "plt.xlabel('Number of trees')\n",
    "plt.ylabel('Accuracy')\n",
    "plt.title('Cross validation accuracy vs number of trees')\n",
    "pass"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Based on the plot above we can see that number of trees does not make a big difference but max_depth makes a very significant differences. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[8, 5000, 0.8320727272727273]"
      ]
     },
     "execution_count": 53,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "max_acc = 0\n",
    "max_num = 0\n",
    "for n in overall_accu_rf:\n",
    "    if n[2] > max_acc:\n",
    "        max_num = n # Get the maximum accuracy combination \n",
    "n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Above is the hyperparameters with the best accuracy, which is tree = 5000 and max_depth = 8. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 53min 50s, sys: 15.2 s, total: 54min 5s\n",
      "Wall time: 18min 58s\n"
     ]
    }
   ],
   "source": [
    "%%time \n",
    "\n",
    "rf = RandomForestClassifier(n_estimators=5000, max_depth=8,n_jobs=-1,random_state=20192019)\n",
    "rf.fit(train_rf,train_label)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "num_images = valid.shape[0]\n",
    "X_test = valid.values.reshape(valid.shape[0], 28, 28, 1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "predicted_classes = model5.predict_classes(X_test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "predicted_classes = pd.DataFrame(predicted_classes)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "predicted_classes.to_csv('pred3.csv')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Predictive accuracy "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "After submitted my both model predictions to the kaggle I got two accuracy: 0.9266 for CNN and 0.8122 for Random Forest. Although they are both slightly lower than their performance in the train set, it's acceptable. I did not find the severe problem about overfitting. \n",
    "\n",
    "I made a barplot to visualize the accuracy. For here I use accuracy instead of classification error because I think it's basically the same: accuracy = 1- classification error and I think presenting accuracy may be more straightforward. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 864x720 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "accu_list = [0.9701454546581616,0.9266,0.8320727272727273,0.8122] #use to compare the performance of two model\n",
    "name_list = ['CNN train accuracy','CNN test accuracy','Random Forest train accuracy','Random Forest test accuracy']\n",
    "fig = plt.figure(figsize=(12,10))\n",
    "plt.bar(x = name_list,height=accu_list)\n",
    "pass"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "From the plot above we can see that CNN is significantly better than the Random Forest model, for both train data and the test data.\n",
    "\n",
    "Then I visualize the predictions:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 864x720 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "Counter(predicted_classes[0])\n",
    "fig = plt.figure(figsize=(12,10))\n",
    "plt.bar(x = list(Counter(predicted_classes[0]).keys()),height=list(Counter(predicted_classes[0]).values()))\n",
    "pass"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "From the visualization above we can see that the prediction for the test test is nearly uniformly distributed, with class 2,7 and 9 slightly more than others. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Errors and the mistakes"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "I think the largest error/mistake I have made during this competition is that I underestimate the running time of some CNN models and the random Forest model. Therefore, I spent a lot of time running these model and waiting for them to be done. \n",
    "\n",
    "Especially the random forest when I was tuning the n_estimators and the max depth I spent more than a day to run the algorithm. If I know it will take that long I will not include that much potential parameters in the tuning step. \n",
    "\n",
    "I think there are two hardest parts of this competetion. First is that there is a large freedom building the CNN model. There are so many potential hyperparameters (number of layers, numbers of neurons in each layer, combinations, etc). So it's definitely a hard task to find the optimal model. The second hardest part is the running time of the model. Since it usually takes a long time to run the CNN and large random forest model, especially I also have to run the cross validation. So It really cost a lot of time in model trainings. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Codes"
   ]
  },
  {
   "cell_type": "raw",
   "metadata": {},
   "source": [
    "# import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import tensorflow as tf\n",
    "import keras\n",
    "from keras.models import Sequential\n",
    "from keras.layers import Dense, Flatten, Conv2D, Dropout, MaxPooling2D,BatchNormalization\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.model_selection import StratifiedKFold\n",
    "from sklearn.model_selection import KFold\n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "from sklearn.metrics import accuracy_score\n",
    "from collections import Counter\n",
    "\n",
    "# Codes to load the dataset \n",
    "train = np.load('train_images.npy')\n",
    "valid = np.load('test_images.npy')\n",
    "train_label = np.load('train_labels.npy')\n",
    "# change the data into pandas dataframe\n",
    "train = pd.DataFrame(train)\n",
    "valid = pd.DataFrame(valid)\n",
    "train_label = pd.DataFrame(train_label)\n",
    "train_label.columns = ['labels']\n",
    "\n",
    "#create the dictionary for each labels \n",
    "#used to output the different fashion styles numbers\n",
    "data_label = {0 : \"T-shirt\", 1: \"Pants\", 2: \"Heavier than shirt\", 3: \"Dress\", 4: \"Coat\",\n",
    "          5: \"Sandal\", 6: \"Shirt\", 7: \"Sneaker\", 8: \"Bag\", 9: \"Ankle Boot\"}\n",
    "\n",
    "label_c = train_label[\"labels\"].value_counts() #count the different label appearance time \n",
    "label_c.keys()[1]\n",
    "d = {}\n",
    "for i in range(len(label_c)):\n",
    "    #append the value counts to the corresponding label names in the data_label dic created above\n",
    "    index = label_c.keys()[i]# get the keys\n",
    "    l = data_label[index] #corresponding to the label name\n",
    "    d[l] = label_c[i]# match the value counts \n",
    "d\n",
    "\n",
    "#Create the visualization of the dic above \n",
    "dd = pd.DataFrame(d,index=[0]).T\n",
    "dd.columns = ['num']\n",
    "fig = plt.subplots(figsize=(15,5))\n",
    "plt.bar(dd.index,dd.num)\n",
    "pass\n",
    "\n",
    "labels = np.load('train_labels.npy')\n",
    "train2 = train.copy()\n",
    "train2['labels'] = labels\n",
    "\n",
    "plt_images = []\n",
    "plt_labels = []\n",
    "\n",
    "    \n",
    "for i in label_c.keys():\n",
    "    #for all labels i in the dataset \n",
    "    s = train2[train2[\"labels\"] == i] # get all observations with the corresponding label i\n",
    "    sample = s.sample(n=5) #randomly sample 5 observations from this label \n",
    "    for j, s in enumerate(sample.values):\n",
    "        img = np.array(sample.iloc[j, :-1]).reshape(28,28) #reshape each observation back to 28x28 pixel matrix\n",
    "        plt_images.append(img) #append the images, used to visualizing \n",
    "        plt_labels.append(sample.iloc[j, -1]) #append the label \n",
    "\n",
    "#plot these sample images for each label \n",
    "f, ax = plt.subplots(5,10, figsize=(16,12))\n",
    "\n",
    "for i, img in enumerate(plt_images):\n",
    "    ax[i//10, i%10].imshow(img, cmap='Blues')\n",
    "    ax[i//10, i%10].axis('off')\n",
    "    ax[i//10, i%10].set_title(data_label[plt_labels[i]])\n",
    "plt.show()    \n",
    "\n",
    "\n",
    "y = keras.utils.to_categorical(train_label.labels, 10) #alternate the dataset ready for CNN \n",
    "num_images = train.shape[0]\n",
    "x_as_array = train.values\n",
    "X = train.values.reshape(num_images, 28, 28, 1)# get ready the X for CNN \n",
    "kf = KFold(n_splits=5,random_state=2019,shuffle=True)# 5 folds split the data \n",
    "\n",
    "model1 = Sequential()# define the model \n",
    "\n",
    "#first add 32 Conv layer \n",
    "model1.add(Conv2D(32, kernel_size=(3, 3),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "#Add a maxpooling layer\n",
    "model1.add(MaxPooling2D((2, 2)))\n",
    "# Add dropout term to avoid overfitting\n",
    "model1.add(Dropout(0.25))\n",
    "# Then add 64 conv layer \n",
    "model1.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "# Add a Maxpooling\n",
    "model1.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "#Add dropout term to avoid overfitting\n",
    "model1.add(Dropout(0.25))\n",
    "#Flatten to prepare for the dense layer\n",
    "model1.add(Flatten())\n",
    "#Add a 64 layer dense layer\n",
    "model1.add(Dense(64, activation='relu'))\n",
    "#Add dropout term to avoid overfitting\n",
    "model1.add(Dropout(0.3))\n",
    "# use softmax to classify to each labels \n",
    "model1.add(Dense(10, activation='softmax'))\n",
    "\n",
    "# define the loss, optimizer and metrics. \n",
    "model1.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])\n",
    "\n",
    "%%time #to calculate the time used \n",
    "\n",
    "overall_accu1 = []\n",
    "for train, test in kf.split(X,y):\n",
    "    # transform train and valid x,y to numpy array\n",
    "    train_x = np.array(X)[train]\n",
    "    train_y = np.array(y)[train]\n",
    "    valid_x = np.array(X)[test]\n",
    "    valid_y = np.array(y)[test]\n",
    "    # fit the model \n",
    "    train_model1 = model1.fit(train_x, train_y,\n",
    "                  batch_size=128,\n",
    "                  epochs=50,\n",
    "                  verbose=0,\n",
    "                  validation_data=(valid_x, valid_y))\n",
    "    # get the validation accuracy for each fold \n",
    "    acc1 = train_model1.history['val_acc'][-1]\n",
    "    overall_accu1.append(acc1)\n",
    "\n",
    "sum(overall_accu1)/5\n",
    "\n",
    "#basically same code as above\n",
    "model11 = Sequential()\n",
    "\n",
    "model11.add(Conv2D(32, kernel_size=(3, 3),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "model11.add(MaxPooling2D((2, 2)))\n",
    "model11.add(Dropout(0.25))\n",
    "model11.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "model11.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model11.add(Dropout(0.25))\n",
    "model11.add(Flatten())\n",
    "model11.add(Dense(128, activation='relu'))\n",
    "model11.add(Dropout(0.3))\n",
    "model11.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model11.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])\n",
    "\n",
    "%%time\n",
    "\n",
    "overall_accu11 = []\n",
    "for train, test in kf.split(X,y):\n",
    "    train_x = np.array(X)[train]\n",
    "    train_y = np.array(y)[train]\n",
    "    valid_x = np.array(X)[test]\n",
    "    valid_y = np.array(y)[test]\n",
    "    train_model11 = model11.fit(train_x, train_y,\n",
    "                  batch_size=128,\n",
    "                  epochs=50,\n",
    "                  verbose=0,\n",
    "                  validation_data=(valid_x, valid_y))\n",
    "    acc11 = train_model11.history['val_acc'][-1]\n",
    "    overall_accu11.append(acc11)\n",
    "\n",
    "sum(overall_accu11)/5\n",
    "\n",
    "#basically same code as above\n",
    "model111 = Sequential()\n",
    "\n",
    "#add two consecutive 32 Conv2D layer \n",
    "model111.add(Conv2D(32, kernel_size=(5, 5),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "model111.add(Conv2D(32, kernel_size=(5, 5),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "model111.add(MaxPooling2D((2, 2)))\n",
    "model111.add(Dropout(0.25))\n",
    "#add two consecutive 64 Conv2D layer \n",
    "model111.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "model111.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "model111.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model111.add(Dropout(0.25))\n",
    "model111.add(Flatten())\n",
    "model111.add(Dense(128, activation='relu'))\n",
    "model111.add(Dropout(0.3))\n",
    "model111.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model111.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])\n",
    "\n",
    "%%time\n",
    "\n",
    "overall_accu111 = []\n",
    "for train, test in kf.split(X,y):\n",
    "    train_x = np.array(X)[train]\n",
    "    train_y = np.array(y)[train]\n",
    "    valid_x = np.array(X)[test]\n",
    "    valid_y = np.array(y)[test]\n",
    "    train_model111 = model111.fit(train_x, train_y,\n",
    "                  batch_size=128,\n",
    "                  epochs=50,\n",
    "                  verbose=0,\n",
    "                  validation_data=(valid_x, valid_y))\n",
    "    acc111 = train_model111.history['val_acc'][-1]\n",
    "    overall_accu111.append(acc111)\n",
    "\n",
    "sum(overall_accu111)/5\n",
    "\n",
    "#basically similar code as above \n",
    "model2 = Sequential()\n",
    "\n",
    "model2.add(Conv2D(16, kernel_size=(3, 3),activation='relu',kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "model2.add(MaxPooling2D((2, 2)))\n",
    "model2.add(Dropout(0.25))\n",
    "model2.add(Conv2D(32, kernel_size=(3, 3), activation='relu'))\n",
    "model2.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model2.add(Dropout(0.25))\n",
    "model2.add(Conv2D(64, (3, 3), activation='relu'))\n",
    "model2.add(Dropout(0.4))\n",
    "model2.add(Flatten())\n",
    "model2.add(Dense(64, activation='relu'))\n",
    "model2.add(Dropout(0.3))\n",
    "model2.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model2.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])\n",
    "\n",
    "\n",
    "%%time \n",
    "\n",
    "overall_accu2 = []\n",
    "for train, test in kf.split(X,y):\n",
    "    train_x = np.array(X)[train]\n",
    "    train_y = np.array(y)[train]\n",
    "    valid_x = np.array(X)[test]\n",
    "    valid_y = np.array(y)[test]\n",
    "    train_model2 = model2.fit(train_x, train_y,\n",
    "                  batch_size=128,\n",
    "                  epochs=50,\n",
    "                  verbose=0,\n",
    "                  validation_data=(valid_x, valid_y))\n",
    "    acc2 = train_model2.history['val_acc'][-1]\n",
    "    overall_accu2.append(acc2)\n",
    "\n",
    "sum(overall_accu2)/5\n",
    "\n",
    "#basically similar code as above \n",
    "model = Sequential()\n",
    "\n",
    "model.add(Conv2D(32, kernel_size=(3, 3),activation='relu',kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "model.add(MaxPooling2D((2, 2)))\n",
    "model.add(Dropout(0.25))\n",
    "model.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "model.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model.add(Dropout(0.25))\n",
    "model.add(Conv2D(128, (3, 3), activation='relu'))\n",
    "model.add(Dropout(0.3))\n",
    "model.add(Flatten())\n",
    "model.add(Dense(128, activation='relu'))\n",
    "model.add(Dropout(0.3))\n",
    "model.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])\n",
    "\n",
    "#basically similar code as above \n",
    "%%time \n",
    "\n",
    "overall_accu = []\n",
    "for train, test in kf.split(X,y):\n",
    "    train_x = np.array(X)[train]\n",
    "    train_y = np.array(y)[train]\n",
    "    valid_x = np.array(X)[test]\n",
    "    valid_y = np.array(y)[test]\n",
    "    train_model = model.fit(train_x, train_y,\n",
    "                  batch_size=128,\n",
    "                  epochs=50,\n",
    "                  verbose=0,\n",
    "                  validation_data=(valid_x, valid_y))\n",
    "    acc = train_model.history['val_acc'][-1]\n",
    "    overall_accu.append(acc)\n",
    "\n",
    "sum(overall_accu)/5\n",
    "\n",
    "#basically similar code as above \n",
    "model3 = Sequential()\n",
    "\n",
    "model3.add(Conv2D(32, kernel_size=(3, 3),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "model3.add(MaxPooling2D((2, 2)))\n",
    "model3.add(Dropout(0.25))\n",
    "model3.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "model3.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model3.add(Dropout(0.25))\n",
    "model3.add(Flatten())\n",
    "model3.add(Dense(128, activation='relu'))\n",
    "model3.add(Dropout(0.25))\n",
    "model3.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model3.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])\n",
    "\n",
    "#basically similar code as above \n",
    "%%time \n",
    "\n",
    "overall_accu3 = []\n",
    "for train, test in kf.split(X,y):\n",
    "    train_x = np.array(X)[train]\n",
    "    train_y = np.array(y)[train]\n",
    "    valid_x = np.array(X)[test]\n",
    "    valid_y = np.array(y)[test]\n",
    "    train_model3 = model3.fit(train_x, train_y,\n",
    "                  batch_size=128,\n",
    "                  epochs=50,\n",
    "                  verbose=0,\n",
    "                  validation_data=(valid_x, valid_y))\n",
    "    acc3 = train_model3.history['val_acc'][-1]\n",
    "    overall_accu3.append(acc3)\n",
    "\n",
    "sum(overall_accu3)/5\n",
    "\n",
    "#basically similar code as above \n",
    "model3_2 = Sequential()\n",
    "\n",
    "model3_2.add(Conv2D(32, kernel_size=(3, 3),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "model3_2.add(MaxPooling2D((2, 2)))\n",
    "model3_2.add(Dropout(0.25))\n",
    "model3_2.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "model3_2.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model3_2.add(Dropout(0.25))\n",
    "model3_2.add(Flatten())\n",
    "model3_2.add(Dense(256, activation='relu'))\n",
    "model3_2.add(Dropout(0.25))\n",
    "model3_2.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model3_2.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])\n",
    "\n",
    "#basically similar code as above \n",
    "%%time \n",
    "\n",
    "overall_accu3_2 = []\n",
    "for train, test in kf.split(X,y):\n",
    "    train_x = np.array(X)[train]\n",
    "    train_y = np.array(y)[train]\n",
    "    valid_x = np.array(X)[test]\n",
    "    valid_y = np.array(y)[test]\n",
    "    train_model3_2 = model3_2.fit(train_x, train_y,\n",
    "                  batch_size=128,\n",
    "                  epochs=50,\n",
    "                  verbose=0,\n",
    "                  validation_data=(valid_x, valid_y))\n",
    "    acc3_2 = train_model3_2.history['val_acc'][-1]\n",
    "    overall_accu3_2.append(acc3_2)\n",
    "\n",
    "sum(overall_accu3_2)/5\n",
    "\n",
    "#basically similar code as above \n",
    "model4 = Sequential()\n",
    "\n",
    "model4.add(Conv2D(32, kernel_size=(3, 3),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "model4.add(MaxPooling2D((2, 2)))\n",
    "model4.add(Dropout(0.25))\n",
    "model4.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "model4.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model4.add(Dropout(0.25))\n",
    "model4.add(Flatten())\n",
    "model4.add(Dense(512, activation='relu'))\n",
    "model4.add(Dropout(0.5))\n",
    "model4.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model4.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])\n",
    "\n",
    "#basically similar code as above \n",
    "%%time \n",
    "\n",
    "overall_accu4 = []\n",
    "for train, test in kf.split(X,y):\n",
    "    train_x = np.array(X)[train]\n",
    "    train_y = np.array(y)[train]\n",
    "    valid_x = np.array(X)[test]\n",
    "    valid_y = np.array(y)[test]\n",
    "    train_model4 = model4.fit(train_x, train_y,\n",
    "                  batch_size=128,\n",
    "                  epochs=50,\n",
    "                  verbose=0,\n",
    "                  validation_data=(valid_x, valid_y))\n",
    "    acc4 = train_model4.history['val_acc'][-1]\n",
    "    overall_accu4.append(acc4)\n",
    "\n",
    "sum(overall_accu4)/5\n",
    "\n",
    "#basically similar code as above \n",
    "model6 = Sequential()\n",
    "\n",
    "model6.add(Conv2D(32, kernel_size=(3, 3),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "model6.add(MaxPooling2D((2, 2)))\n",
    "model6.add(Dropout(0.25))\n",
    "model6.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "model6.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model6.add(Dropout(0.25))\n",
    "model6.add(Flatten())\n",
    "model6.add(Dense(1028, activation='relu'))\n",
    "model6.add(Dropout(0.5))\n",
    "model6.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model6.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])\n",
    "\n",
    "#basically similar code as above \n",
    "%%time \n",
    "\n",
    "overall_accu6 = []\n",
    "for train, test in kf.split(X,y):\n",
    "    train_x = np.array(X)[train]\n",
    "    train_y = np.array(y)[train]\n",
    "    valid_x = np.array(X)[test]\n",
    "    valid_y = np.array(y)[test]\n",
    "    train_model6 = model6.fit(train_x, train_y,\n",
    "                  batch_size=128,\n",
    "                  epochs=50,\n",
    "                  verbose=0,\n",
    "                  validation_data=(valid_x, valid_y))\n",
    "    acc6 = train_model6.history['val_acc'][-1]\n",
    "    overall_accu6.append(acc6)\n",
    "\n",
    "sum(overall_accu6)/5\n",
    "\n",
    "#basically similar code as above \n",
    "model5 = Sequential()\n",
    "\n",
    "model5.add(Conv2D(32, kernel_size=(3, 3),activation='relu', kernel_initializer='he_normal',input_shape=(28, 28, 1)))\n",
    "model5.add(BatchNormalization())\n",
    "model5.add(MaxPooling2D((2, 2)))\n",
    "model5.add(Dropout(0.25))\n",
    "model5.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))\n",
    "model5.add(BatchNormalization())\n",
    "model5.add(MaxPooling2D(pool_size=(2, 2)))\n",
    "model5.add(Dropout(0.25))\n",
    "model5.add(Flatten())\n",
    "model5.add(Dense(512, activation='relu'))\n",
    "model5.add(BatchNormalization())\n",
    "model5.add(Dropout(0.5))\n",
    "model5.add(Dense(10, activation='softmax'))\n",
    "\n",
    "\n",
    "model5.compile(loss=keras.losses.categorical_crossentropy,\n",
    "              optimizer='adam',\n",
    "              metrics=['accuracy'])\n",
    "\n",
    "%%time\n",
    "#basically similar code as above \n",
    " \n",
    "overall_accu5 = []\n",
    "for train, test in kf.split(X,y):\n",
    "    train_x = np.array(X)[train]\n",
    "    train_y = np.array(y)[train]\n",
    "    valid_x = np.array(X)[test]\n",
    "    valid_y = np.array(y)[test]\n",
    "    train_model5 = model5.fit(train_x, train_y,\n",
    "                  batch_size=128,\n",
    "                  epochs=50,\n",
    "                  verbose=0,\n",
    "                  validation_data=(valid_x, valid_y))\n",
    "    acc5 = train_model5.history['val_acc'][-1]\n",
    "    overall_accu5.append(acc5)\n",
    "\n",
    "sum(overall_accu5)/5\n",
    "\n",
    "%%time \n",
    "\n",
    "train_model4 = model4.fit(X, y,\n",
    "                  batch_size=128,\n",
    "                  epochs=50,\n",
    "                  verbose=0)\n",
    "\n",
    "# append all cross validation accuracy to a single list \n",
    "accus = np.array([overall_accu2,overall_accu,sum(overall_accu3_2)/5,sum(overall_accu4)/5,sum(overall_accu6)/5]) \n",
    "# append the corresponding dense layer number\n",
    "dense = np.array([64,128,256,512,1028])\n",
    "# plot the plot \n",
    "plt.plot(dense,accus)\n",
    "plt.ylabel('Accuracy')\n",
    "plt.xlabel('Dense layers')\n",
    "plt.title('Cross Validation accuracy vs. dense layers')\n",
    "pass\n",
    "\n",
    "#prepare the dataset \n",
    "train = np.load('train_images.npy')\n",
    "valid = np.load('test_images.npy')\n",
    "train_label = np.load('train_labels.npy')\n",
    "train_rf = pd.DataFrame(train)\n",
    "valid_rf = pd.DataFrame(valid)\n",
    "train_y_rf = pd.DataFrame(train_label)\n",
    "\n",
    "kf_rf = KFold(n_splits=10,random_state=2022,shuffle=True) # set the 10 folds cross validation\n",
    "l1 = [50,100,200,400,700,1000,1500,2000,3000,5000] # set the number of trees for tuning parameter\n",
    "l2 = [4,5,6,8] # set the max depth of trees for tuning parameter\n",
    "\n",
    "%%time \n",
    "\n",
    "overall_accu_rf = []\n",
    "for i in l2:\n",
    "    for j in l1:\n",
    "        #for different max depth and different number of trees \n",
    "        tmp_acc = []\n",
    "        # define the randomforest classifier\n",
    "        rf = RandomForestClassifier(n_estimators=j, max_depth=i,n_jobs=-1,random_state=20192019)\n",
    "        for train, test in kf_rf.split(train_rf,train_label):\n",
    "            # change the data to numpy arrays\n",
    "            train_x = np.array(train_rf)[train]\n",
    "            train_y = np.array(train_label)[train]\n",
    "            valid_x = np.array(train_rf)[test]\n",
    "            valid_y = np.array(train_label)[test]\n",
    "            # fit the training data\n",
    "            rf.fit(train_x,train_y)\n",
    "            # pred the validation set \n",
    "            pred = rf.predict(valid_x)\n",
    "            acc_rf = accuracy_score(valid_y, pred)\n",
    "            tmp_acc.append(acc_rf)\n",
    "        overall_accu_rf.append([i,j,sum(tmp_acc)/10])\n",
    "\n",
    "acc_plt = []\n",
    "n_tree = []\n",
    "acc_plt4 = []\n",
    "acc_plt5 = []\n",
    "acc_plt6 = []\n",
    "acc_plt8 = []\n",
    "n_tree4 = []\n",
    "n_tree5 = []\n",
    "n_tree6 = []\n",
    "n_tree8 = []\n",
    "labels = [4,5,6,8]\n",
    "colors = [\"black\",\"yellow\",\"orange\",\"purple\"] #define the different color for different max depth \n",
    "for n in range(40):\n",
    "    #the first 10 are max_depth 4's accuracy\n",
    "    if n < 10:\n",
    "        acc_plt4.append(overall_accu_rf[n][2])\n",
    "        n_tree4.append(overall_accu_rf[n][1])\n",
    "    #the 11-20 are max_depth 5's accuracy\n",
    "    elif n < 20 and n >= 10:\n",
    "        acc_plt5.append(overall_accu_rf[n][2])\n",
    "        n_tree5.append(overall_accu_rf[n][1])\n",
    "    #the 21-30 are max_depth 5's accuracy\n",
    "    elif n < 30 and n >= 20:\n",
    "        acc_plt6.append(overall_accu_rf[n][2])\n",
    "        n_tree6.append(overall_accu_rf[n][1])\n",
    "    #the 31-40 are max_depth 5's accuracy\n",
    "    elif n < 40 and n >= 30:\n",
    "        acc_plt8.append(overall_accu_rf[n][2])\n",
    "        n_tree8.append(overall_accu_rf[n][1])\n",
    "#append the accuracy and n_tree lists to the overall lists use for visualization \n",
    "acc_plt.append(acc_plt4)\n",
    "acc_plt.append(acc_plt5)\n",
    "acc_plt.append(acc_plt6)\n",
    "acc_plt.append(acc_plt8)\n",
    "n_tree.append(n_tree4)\n",
    "n_tree.append(n_tree5)\n",
    "n_tree.append(n_tree6)\n",
    "n_tree.append(n_tree8)\n",
    "for i, color in zip(range(4),colors):\n",
    "    plt.plot(n_tree[i], acc_plt[i], color=colors[i],label='max_depth {0}' #plot the different max_depth's accuracy\n",
    "    ''.format(labels[i])) #differentiated by the color \n",
    "plt.legend(loc=\"lower right\",prop={'size': 8})\n",
    "plt.xlabel('Number of trees')\n",
    "plt.ylabel('Accuracy')\n",
    "plt.title('Cross validation accuracy vs number of trees')\n",
    "pass\n",
    "\n",
    "max_acc = 0\n",
    "max_num = 0\n",
    "for n in overall_accu_rf:\n",
    "    if n[2] > max_acc:\n",
    "        max_num = n # Get the maximum accuracy combination \n",
    "n\n",
    "\n",
    "%%time \n",
    "\n",
    "rf = RandomForestClassifier(n_estimators=5000, max_depth=8,n_jobs=-1,random_state=20192019)\n",
    "rf.fit(train_rf,train_label)\n",
    "num_images = valid.shape[0]\n",
    "X_test = valid.values.reshape(valid.shape[0], 28, 28, 1)\n",
    "\n",
    "predicted_classes = model5.predict_classes(X_test)\n",
    "predicted_classes = pd.DataFrame(predicted_classes)\n",
    "accu_list = [0.9701454546581616,0.9266,0.8320727272727273,0.8122] #use to compare the performance of two model\n",
    "name_list = ['CNN train accuracy','CNN test accuracy','Random Forest train accuracy','Random Forest test accuracy']\n",
    "fig = plt.figure(figsize=(12,10))\n",
    "plt.bar(x = name_list,height=accu_list)\n",
    "pass\n",
    "\n",
    "Counter(predicted_classes[0])\n",
    "fig = plt.figure(figsize=(12,10))\n",
    "plt.bar(x = list(Counter(predicted_classes[0]).keys()),height=list(Counter(predicted_classes[0]).values()))\n",
    "pass\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
